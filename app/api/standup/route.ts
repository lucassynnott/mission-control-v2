import { NextRequest, NextResponse } from 'next/server';
import { supabase } from '@/lib/supabase';

/**
 * Daily Standup Generation
 * 
 * POST: Generate standup for last 24 hours
 * 
 * Returns markdown-formatted standup with:
 * - Tasks completed
 * - Tasks in progress
 * - Blocked tasks
 * - Tasks needing review
 * - Key decisions
 */

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const { hours = 24, sendToTelegram = false } = body;

    const cutoffTime = new Date(Date.now() - hours * 60 * 60 * 1000).toISOString();

    // Fetch completed tasks (last 24h)
    const { data: completedTasks } = await supabase
      .from('tasks')
      .select('*, agent:assignee')
      .eq('column_status', 'done')
      .gte('updated_at', cutoffTime)
      .order('updated_at', { ascending: false });

    // Fetch in-progress tasks
    const { data: inProgressTasks } = await supabase
      .from('tasks')
      .select('*, agent:assignee')
      .eq('column_status', 'in_progress')
      .order('updated_at', { ascending: false });

    // Fetch blocked tasks
    const { data: blockedTasks } = await supabase
      .from('tasks')
      .select('*, agent:assignee')
      .eq('column_status', 'blocked')
      .order('updated_at', { ascending: false });

    // Fetch review tasks
    const { data: reviewTasks } = await supabase
      .from('tasks')
      .select('*, agent:assignee')
      .eq('column_status', 'review')
      .order('updated_at', { ascending: false });

    // Fetch key activities (decisions, major updates)
    const { data: decisions } = await supabase
      .from('activities')
      .select('*')
      .in('type', ['system', 'agent'])
      .gte('timestamp', cutoffTime)
      .order('timestamp', { ascending: false })
      .limit(10);

    // Generate standup content
    const standup = generateStandupMarkdown({
      completed: completedTasks || [],
      inProgress: inProgressTasks || [],
      blocked: blockedTasks || [],
      review: reviewTasks || [],
      decisions: decisions || [],
      hours,
    });

    // Optionally send to Telegram
    if (sendToTelegram) {
      await sendStandupToTelegram(standup);
    }

    // Save to Obsidian (optional)
    // await saveStandupToObsidian(standup);

    return NextResponse.json({
      success: true,
      standup,
      stats: {
        completed: completedTasks?.length || 0,
        inProgress: inProgressTasks?.length || 0,
        blocked: blockedTasks?.length || 0,
        review: reviewTasks?.length || 0,
        decisions: decisions?.length || 0,
      },
    });
  } catch (error: any) {
    console.error('Standup generation error:', error);
    return NextResponse.json(
      { error: 'Failed to generate standup', details: error.message },
      { status: 500 }
    );
  }
}

interface StandupData {
  completed: any[];
  inProgress: any[];
  blocked: any[];
  review: any[];
  decisions: any[];
  hours: number;
}

function generateStandupMarkdown(data: StandupData): string {
  const { completed, inProgress, blocked, review, decisions, hours } = data;
  const now = new Date();
  const dateStr = now.toLocaleDateString('en-US', { 
    weekday: 'long', 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric' 
  });

  let md = `ðŸ“Š **DAILY STANDUP** â€” ${dateStr}\n`;
  md += `*Last ${hours} hours*\n\n`;

  // Completed tasks
  if (completed.length > 0) {
    md += `âœ… **COMPLETED TODAY** (${completed.length})\n`;
    completed.forEach(task => {
      const agent = task.assignee || 'Unassigned';
      md += `â€¢ **${agent}**: ${task.title}\n`;
    });
    md += `\n`;
  } else {
    md += `âœ… **COMPLETED TODAY**\n`;
    md += `â€¢ No tasks completed\n\n`;
  }

  // In progress
  if (inProgress.length > 0) {
    md += `ðŸ”„ **IN PROGRESS** (${inProgress.length})\n`;
    inProgress.slice(0, 10).forEach(task => {
      const agent = task.assignee || 'Unassigned';
      md += `â€¢ **${agent}**: ${task.title}\n`;
    });
    if (inProgress.length > 10) {
      md += `â€¢ *...and ${inProgress.length - 10} more*\n`;
    }
    md += `\n`;
  }

  // Blocked
  if (blocked.length > 0) {
    md += `ðŸš« **BLOCKED** (${blocked.length})\n`;
    blocked.forEach(task => {
      const agent = task.assignee || 'Unassigned';
      md += `â€¢ **${agent}**: ${task.title}\n`;
    });
    md += `\n`;
  }

  // Needs review
  if (review.length > 0) {
    md += `ðŸ‘€ **NEEDS REVIEW** (${review.length})\n`;
    review.forEach(task => {
      const agent = task.assignee || 'Unassigned';
      md += `â€¢ **${agent}**: ${task.title}\n`;
    });
    md += `\n`;
  }

  // Key decisions
  if (decisions.length > 0) {
    md += `ðŸ“ **KEY DECISIONS**\n`;
    decisions.slice(0, 5).forEach(decision => {
      md += `â€¢ ${decision.message}\n`;
    });
    md += `\n`;
  }

  md += `---\n`;
  md += `*Generated by Mission Control v2.0*\n`;
  md += `*[View Dashboard](${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:3006'})*`;

  return md;
}

async function sendStandupToTelegram(standup: string): Promise<void> {
  try {
    // Use OpenClaw message API to send to Lucas's Telegram
    const response = await fetch(`${process.env.OPENCLAW_API_URL || 'http://localhost:8765'}/api/message/send`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.OPENCLAW_API_KEY || ''}`,
      },
      body: JSON.stringify({
        channel: 'telegram',
        to: process.env.LUCAS_TELEGRAM_ID || '417119499',
        message: standup,
      }),
    });

    if (!response.ok) {
      console.error('Failed to send standup to Telegram:', await response.text());
    } else {
      console.log('Standup sent to Telegram successfully');
    }
  } catch (err) {
    console.error('Telegram send error:', err);
  }
}
